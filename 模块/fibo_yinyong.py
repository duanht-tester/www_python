# -*- encoding: UTF-8 -*-
# __author__ = 'lenovo'

from 模块.fib import fib01

"""
这样做并没有把直接定义在fibo中的函数名称写入到当前符号表里，只是把模块fibo的名字写到了那里。
可以使用模块名称来访问函数：
"""
# fib.fib(10)
# print(fib.fib02(100))
# print(fib.__name__)

"""
from … import 语句
Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：
from modname import name1[, name2[, ... nameN]]
"""
# 例如，要导入模块 fibo 的 fib 函数，使用如下语句：
# fib01(100)
# 这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。
"""
from … import * 语句
把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：

from modname import *
这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。
"""
"""
深入模块
模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。
这些代码只有在第一次被导入时才会被执行。
每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。
所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混。
从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname
这样的表示法来访问模块内的函数。
模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用
import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入
当前操作的模块的符号表中。
还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）
名称导入到当前操作模块。比如:
"""
# fib01(500)
from 模块.fib import *
fib01(10)
"""
这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况，
 Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。
"""
"""
__name__属性
一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，
模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。
"""




