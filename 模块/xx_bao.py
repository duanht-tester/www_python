# __author__ = 'lenovo'


"""
包
包是一种管理 Python 模块命名空间的形式，采用"点模块名称"。
比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。
就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，
采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。
这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。
不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个"包"）。
现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如：
 .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，
 用来在不同的格式之间转换。
并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，
创建人造立体声效果），所以你还需要一组怎么也写不完的模块来处理这些操作。
这里给出了一种可能的包结构（在分层的文件系统中）:
"""
"""
sound/                          顶层包
      __init__.py               初始化 sound 包
      formats/                  文件格式转换子包
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  声音效果子包
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  filters 子包
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
"""
"""
在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。
目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，主要是为了避免一
些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。
最简单的情况，放一个空的 :file:__init__.py就可以了。当然这个文件中也可以包含
一些初始化代码或者为（将在后面介绍的） __all__变量赋值。
用户可以每次只导入一个包里面的特定模块，比如:
"""

import sound.effects.echo
# 这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:
sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
# 还有一种导入子模块的方法是:
from sound.effects import echo
# 这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:
echo.echofilter(input, output, delay=0.7, atten=4)
# 还有一种变化就是直接导入一个函数或者变量:
from sound.effects.echo import echofilter
# 同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数:
echofilter(input, output, delay=0.7, atten=4)
"""
注意当使用 from package import item 这种形式的时候，对应的 item 既
可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。
import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。
如果还没找到，抛出一个 :exc:ImportError 异常。
反之，如果使用形如 import item.subitem.subsubitem 这种导入形式，除了最后一项，
都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。
"""
"""
从一个包中导入*
设想一下，如果我们使用 from sound.effects import *会发生什么？
Python 会进入文件系统，找到这个包里面所有的子模块，一个一个的把它们都导入进来。
但是很不幸，这个方法在 Windows平台上工作的就不是非常好，因为Windows是一个
大小写不区分的系统。
在这类平台上，没有人敢担保一个叫做 ECHO.py 的文件导入为模块 echo 还是 Echo 甚至 ECHO。
（例如，Windows 95就很讨厌的把每一个文件的首字母大写显示）而且 DOS 的 8+3 命名规则
对长模块名称的处理会把问题搞得更纠结。
为了解决这个问题，只能烦劳包作者提供一个精确的包的索引了。
导入语句遵循如下规则：如果包定义文件 __init__.py 存在一个叫做 __all__
的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有
名字作为包内容导入。
作为包的作者，可别忘了在更新包之后保证 __all__ 也更新了啊。你说我就不这么做，
我就不使用导入*这种用法，好吧，没问题，谁让你是老板呢。这里有一个例子，
在:file:sounds/effects/__init__.py中包含如下代码:
"""
__all__ = ["echo", "surround", "reverse"]
"""
这表示当你使用from sound.effects import *这种用法时，你只会导入包里面这三个子模块。
如果 __all__ 真的没有定义，那么使用from sound.effects import *这种语法的时候，
就不会导入包 sound.effects 里的任何子模块。他只是把包sound.effects和它里面定
义的所有内容导入进来（可能运行__init__.py里定义的初始化代码）。
这会把 __init__.py 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话
之前导入的所有明确指定的模块。看下这部分代码:
"""
import sound.effects.echo
import sound.effects.surround
from sound.effects import *
"""
这个例子中，在执行 from...import 前，包 sound.effects 中的 echo 和 surround
模块都被导入到当前的命名空间中了。（当然如果定义了 __all__ 就更没问题了）
通常我们并不主张使用 * 这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。
不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。
记住，使用 from Package import specific_submodule 这种方法永远不会有错。事实上，
这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。
如果在结构中包是一个子包（比如这个例子中对于包sound来说），而你又想导入
兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块
sound.filters.vocoder 要使用包 sound.effects 中的模块 echo，你就要写成
 from sound.effects import echo。
"""
from . import echo
from .. import formats
from ..filters import equalizer
"""
无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是"__main__"，
一个Python应用程序的主模块，应当总是使用绝对路径引用。
包还提供一个额外的属性__path__。这是一个目录列表，里面每一个包含的目录都有为这
个包服务的__init__.py，你得在其他__init__.py被执行前定义哦。可以修改这个变
量，用来影响包含在包里面的模块和子包。
这个功能并不常用，一般用来扩展包里面的模块。
"""
"""
from modname import *
这一句里的星号应该是沿用自正则中一样的意义，表示的是全部的意思，文中指出少用这种导
入方式，我觉得是如果将一个模块的所有函数名导入当前命名空间中，如果不同模块包含了
函数名相同的函数，或者是与自己编写得函数名相同将会导致混乱，而且在 debug 时还不容易发现。
"""
"""
在需要导入包中所有模块时，import* 还是有意义的。
只需要在 __init__.py 文件里面将所有模块名定义在列表 __ALL__ 中就能解决你最后的担忧。
"""
"""
from modname import *
这种方式进行导入，如果不同模块之间有相同的函数命名，最后导入的会覆盖前面的，
也就是说只会调用到最后导入进的函数。
"""
"""
关于导入模块，自己写的程序，自己也可以把它保存下来，以后需要的时候导入使用，
例如下面所示。
我有个代码名称为 test1.py，它的所在路径为 D:\test 下面。那我只需要完成
以下步骤就可以把它作为模块 import 到其他代码中了。
 1.import sys
 2.sys.path.append("D:\\test")
在 test2.py 中我们就可以直接 import test1.py 了。成功导入后，
test1中 的方法也就可以在 test2 中进行使用。
import test1
"""

























